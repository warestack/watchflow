import structlog

from src.core.models import HygieneMetrics
from src.integrations.github.models import PullRequest

logger = structlog.get_logger()

AI_DETECTION_KEYWORDS = [
    "generated by claude",
    "cursor",
    "copilot",
    "chatgpt",
    "ai-generated",
    "llm",
    "i am an ai",
    "as an ai",
]


def calculate_hygiene_metrics(prs: list[PullRequest]) -> HygieneMetrics:
    """
    Computes hygiene signals from a batch of Pull Requests.

    Implements deterministic logic for the "AI Immune System" metrics.
    Pure function: No side effects or network calls.

    Args:
        prs: Validated PullRequest models.

    Returns:
        HygieneMetrics: Aggregated signals for the Rule Engine.
    """
    total_prs = len(prs)

    if total_prs == 0:
        return HygieneMetrics(
            unlinked_issue_rate=0.0,
            average_pr_size=0,
            first_time_contributor_count=0,
            issue_diff_mismatch_rate=0.0,
            ghost_contributor_rate=0.0,
            new_code_test_coverage=0.0,
            codeowner_bypass_rate=0.0,
            ai_generated_rate=0.0,
        )

    # 1. Average PR Size (LOC)
    # Requirement: Calculated via additions/deletions, not file size in bytes.
    total_loc = sum(pr.additions + pr.deletions for pr in prs)
    average_pr_size = total_loc / total_prs if total_prs > 0 else 0

    # 2. Unlinked Issue Rate
    # Governance: PRs must link to tracking issues for tracebility.
    unlinked_count = sum(1 for pr in prs if not pr.closing_issues_references.nodes)
    unlinked_issue_rate = unlinked_count / total_prs

    # 3. Ghost Contributor Rate (Engagement)
    # Heuristic: Author has 0 comments on their own PR despite reviewer activity.
    # Proxy for "Throw over the wall" contribution style.
    ghost_count = sum(1 for pr in prs if pr.comments.total_count == 0 and pr.reviews.nodes)
    ghost_contributor_rate = ghost_count / total_prs

    # 4. Issue-Diff Mismatch Rate
    # Heuristic: Checks if Issue Title keywords overlap with changed file paths.
    issue_diff_mismatch_count = 0
    for pr in prs:
        if not pr.closing_issues_references.nodes:
            continue

        issue_title = pr.closing_issues_references.nodes[0].title.lower()
        changed_paths = [edge.node.path for edge in pr.files.edges]

        match_found = False
        for path in changed_paths:
            # Tokenize path for loose matching
            path_parts = path.replace("/", " ").replace(".", " ").split()
            for part in path_parts:
                if len(part) > 3 and part.lower() in issue_title:
                    match_found = True
                    break
            if match_found:
                break

        if not match_found:
            issue_diff_mismatch_count += 1

    issue_diff_mismatch_rate = issue_diff_mismatch_count / total_prs

    # 5. Codeowner Bypass Rate
    # Constraint: Must have APPROVED review from someone other than the author.
    codeowner_bypass_count = 0
    for pr in prs:
        author_login = pr.author.login if pr.author else ""
        reviews = pr.reviews.nodes

        has_approval = any(
            r.state == "APPROVED" and (r.author.login != author_login if r.author else False) for r in reviews
        )
        if not has_approval:
            codeowner_bypass_count += 1

    codeowner_bypass_rate = codeowner_bypass_count / total_prs

    # 6. CI Skip Rate
    # Metric: Percentage of recent commits containing [skip ci] or similar.
    # Note: Using last commit message from each PR as a proxy.
    ci_skip_count = 0
    for pr in prs:
        if not pr.commits.nodes:
            continue
        message = pr.commits.nodes[0].commit.message.lower()
        if "[skip ci]" in message or "[ci skip]" in message or "[no ci]" in message:
            ci_skip_count += 1

    ci_skip_rate = ci_skip_count / total_prs if total_prs > 0 else 0.0

    # 7. AI Generated Rate
    # Signature Based Detection (Phase 1 Heuristic).
    ai_generated_count = 0
    for pr in prs:
        content = (pr.body or "").lower() + (pr.title or "").lower()
        if any(k in content for k in AI_DETECTION_KEYWORDS):
            ai_generated_count += 1
    ai_generated_rate = ai_generated_count / total_prs

    return HygieneMetrics(
        unlinked_issue_rate=round(unlinked_issue_rate, 2),
        average_pr_size=int(average_pr_size),
        first_time_contributor_count=0,  # Defer to Phase 2 (User Enrichment)
        issue_diff_mismatch_rate=round(issue_diff_mismatch_rate, 2),
        ghost_contributor_rate=round(ghost_contributor_rate, 2),
        new_code_test_coverage=0.0,  # Defer to Phase 2 (CI Integration)
        ci_skip_rate=round(ci_skip_rate, 2),
        codeowner_bypass_rate=round(codeowner_bypass_rate, 2),
        ai_generated_rate=round(ai_generated_rate, 2),
    )
